struct PS_IN{
    float4 position: SV_Position;
    float4 worldPosition: WorldPosition;
    float2 texCoords: TexCoords;
    float3x3 TBN: TBNMatrix;
};

struct PS_OUT{
    float4 gPositions: SV_TARGET0;
    float4 gNormals : SV_TARGET1;
    float4 gAlbedo : SV_TARGET2;
    float4 gMrao : SV_TARGET3;
};

SamplerState splr: register(s0);

Texture2D materialTex: register(t0);

static const float NUM_TEXTURES = 5.0;
static const float TEXTURE_SIZE = 1.0f / NUM_TEXTURES;

PS_OUT main(PS_IN psIn){
    float2 texCoords = psIn.texCoords;
    texCoords.x = texCoords.x * TEXTURE_SIZE;
    texCoords.y = 1.0f - texCoords.y;

    float4 color = materialTex.Sample(splr, texCoords);
    texCoords.x += TEXTURE_SIZE;
    float3 normal = normalize(2.0f * materialTex.Sample(splr, texCoords).xyz - 1.0f);
    texCoords.x += TEXTURE_SIZE;
    float3 N = normalize(mul(normal, psIn.TBN));

    float metallic = materialTex.Sample(splr, texCoords).x;
    texCoords.x += TEXTURE_SIZE;
    float roughness = materialTex.Sample(splr, texCoords).x;
    texCoords.x += TEXTURE_SIZE;
    float ao = materialTex.Sample(splr, texCoords).x;

    PS_OUT psOut;
    psOut.gPositions = psIn.worldPosition;
    psOut.gNormals = float4(N, 0.0f);
    psOut.gAlbedo = color;
    psOut.gMrao = float4(metallic, roughness, ao, 1.0f); // 1.0f indicates that this is a valid fragment

    return psOut;
}